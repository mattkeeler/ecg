;; elisp-indent.lisp -- Indent Emacs Lisp code

;;; Commentary:

;; A script to indent Emacs Lisp code.
;;
;; Based on "lispindent.lisp" by Dorai Sitaram, see
;; https://ds26gte.github.io/ and
;; https://github.com/ds26gte/scmindent/blob/master/lispindent.lisp.

;; Code:

(defpackage :elisp-indent
  (:export #:indent-lines #:with-indenting-output)
  (:use :common-lisp))
(in-package :elisp-indent)

(defvar *lisp-keywords*
  '(("and-let*" . 1)
    ("atomic-change-group" . 0)
    ("backtrace--with-output-variables" . 1)
    ("benchmark-progn" . 0)
    ("benchmark-run" . 1)
    ("benchmark-run-compiled" . 1)
    ("bindings--define-key" . 2)
    ("byte-compile-maybe-guarded" . 1)
    ("byte-optimize--pcase" . 1)
    ("catch" . 1)
    ("closure" . 2)
    ("combine-after-change-calls" . 0)
    ("combine-change-calls" . 2)
    ("comment-with-narrowing" . 2)
    ("condition-case" . 2)
    ("condition-case-unless-debug" . 2)
    ("debugger-env-macro" . 0)
    ("def-edebug-elem-spec" . 1)
    ("def-edebug-spec" . 1)
    ("defadvice" . 2)
    ("define-advice" . 2)
    ("define-generic-mode" . 1)
    ("define-ibuffer-filter" . 2)
    ("define-ibuffer-op" . 2)
    ("define-ibuffer-sorter" . 1)
    ("defmacro" . 2)
    ("defsubst" . 2)
    ("deftheme" . 1)
    ("defun" . 2)
    ("defvar-keymap" . 1)
    ("defvar-local" . 2)
    ("delay-mode-hooks" . 0)
    ("dlet" . 1)
    ("dolist" . 1)
    ("dolist-with-progress-reporter" . 2)
    ("dont-compile" . 0)
    ("dotimes" . 1)
    ("dotimes-with-progress-reporter" . 2)
    ("easy-mmode-defmap" . 1)
    ("easy-mmode-defsyntax" . 1)
    ("eldoc--documentation-strategy-defcustom" . 2)
    ("ert-deftest" . 2)
    ("eval-after-load" . 1)
    ("eval-and-compile" . 0)
    ("eval-when-compile" . 0)
    ("gv-define-expander" . 1)
    ("gv-define-setter" . 2)
    ("gv-letplace" . 2)
    ("handler-bind" . 1)
    ("handler-case" . 1)
    ("if" . 2)
    ("if-let" . 2)
    ("if-let*" . 2)
    ("ignore-error" . 1)
    ("ignore-errors" . 0)
    ("lambda" . 1)
    ("let" . 1)
    ("let*" . 1)
    ("let-alist" . 1)
    ("let-when-compile" . 1)
    ("letrec" . 1)
    ("macroexp--accumulate" . 1)
    ("macroexp-let2" . 3)
    ("macroexp-let2*" . 2)
    ("minibuffer-with-setup-hook" . 1)
    ("named-let" . 2)
    ("pcase" . 1)
    ("pcase-defmacro" . 2)
    ("pcase-dolist" . 1)
    ("pcase-exhaustive" . 1)
    ("pcase-let" . 1)
    ("pcase-let*" . 1)
    ("prog1" . 1)
    ("prog2" . 2)
    ("progn" . 0)
    ("replace--push-stack" . 0)
    ("rx-let" . 1)
    ("rx-let-eval" . 1)
    ("save-current-buffer" . 0)
    ("save-excursion" . 0)
    ("save-mark-and-excursion" . 0)
    ("save-match-data" . 0)
    ("save-restriction" . 0)
    ("save-selected-window" . 0)
    ("save-window-excursion" . 0)
    ("seq-doseq" . 1)
    ("seq-let" . 2)
    ("thread-first" . 0)
    ("thread-last" . 0)
    ("track-mouse" . 0)
    ("unless" . 1)
    ("unwind-protect" . 1)
    ("when" . 1)
    ("when-let" . 1)
    ("when-let*" . 1)
    ("while" . 1)
    ("while-no-input" . 0)
    ("with-auto-compression-mode" . 0)
    ("with-case-table" . 1)
    ("with-category-table" . 1)
    ("with-coding-priority" . 1)
    ("with-current-buffer" . 1)
    ("with-current-buffer-window" . 3)
    ("with-delayed-message" . 1)
    ("with-demoted-errors" . 1)
    ("with-displayed-buffer-window" . 3)
    ("with-environment-variables" . 1)
    ("with-eval-after-load" . 1)
    ("with-existing-directory" . 0)
    ("with-file-modes" . 1)
    ("with-help-window" . 1)
    ("with-local-quit" . 0)
    ("with-locale-environment" . 1)
    ("with-memoization" . 1)
    ("with-minibuffer-selected-window" . 0)
    ("with-mutex" . 1)
    ("with-no-warnings" . 0)
    ("with-output-to-string" . 0)
    ("with-output-to-temp-buffer" . 1)
    ("with-selected-frame" . 1)
    ("with-selected-window" . 1)
    ("with-silent-modifications" . 0)
    ("with-suppressed-warnings" . 1)
    ("with-syntax-table" . 1)
    ("with-temp-buffer" . 0)
    ("with-temp-buffer-window" . 3)
    ("with-temp-file" . 1)
    ("with-temp-message" . 1)
    ("with-timeout" . 1)
    ("with-undo-amalgamate" . 0)
    ("with-window-non-dedicated" . 1)
    ("with-wrapper-hook" . 2)))

(defun set-lisp-indent-number (sym num-of-subforms-to-be-indented-wide)
  (let* ((x (symbol-name sym))
         (c (assoc x *lisp-keywords* :test #'string-equal)))
    (unless c
      (push (setq c (cons x nil)) *lisp-keywords*))
    (setf (cdr c) num-of-subforms-to-be-indented-wide)))

(defun past-next-atom (s i n)
  (loop
    (when (>= i n) (return n))
    (let ((c (char s i)))
      (cond ((char= c #\\) (incf i))
            ((member c '(#\space #\tab #\( #\) #\[ #\] #\" #\' #\` #\, #\;))
             (return i))))
    (incf i)))

(defun get-lisp-indent-number (s &optional (possible-keyword-p t))
  (or (cdr (assoc s *lisp-keywords* :test #'string-equal))
      (if (zerop (or (search "def" s :test #'char-equal) -1))
          0
          (if possible-keyword-p
              (let ((p (position #\: s :from-end t)))
                (if p
                    (get-lisp-indent-number (subseq s (1+ p)) nil)
                    -1))
              -1))))

(defun literal-token-p (s)
  (let ((colon-pos (position #\: s)))
    (if colon-pos
        (if (= colon-pos 0) t nil)
        (let ((s (read-from-string s)))
          (or (characterp s) (numberp s) (stringp s))))))

(defstruct lparen
  spaces-before
  lisp-indent-num
  num-finished-subforms)

(defun calc-subindent (s i n)
  (let* ((j (past-next-atom s i n))
         (lisp-indent-num 0)
         (delta-indent
           (if (= j i) 0
               (let ((w (subseq s i j)))
                 (if (or (and (>= i 2) (member (char s (- i 2)) '(#\' #\`)))
                         (literal-token-p w)) 0
                         (progn (setq lisp-indent-num (get-lisp-indent-number w))
                                (case lisp-indent-num
                                  ((-2) 0)
                                  ((-1) (if (< j n) (+ (- j i) 1) 1))
                                  (t 1))))))))
    (values delta-indent lisp-indent-num j)))

(defun num-leading-spaces (s)
  (let ((n (length s))
        (i 0) (j 0))
    (loop
      (when (>= i n) (return 0))
      (case (char s i)
        (#\space (incf i) (incf j))
        (#\tab (incf i) (incf j 8))
        (t (return j))))))

(defun string-trim-blanks (s)
  (string-trim '(#\space #\tab #\newline #\return) s))

(defun indent-lines ()
  (let ((left-i 0) (paren-stack '()) (inside-stringp nil))
    (loop
      (let* ((curr-line (or (read-line nil nil) (return)))
             (leading-spaces (num-leading-spaces curr-line))
             (curr-left-i
               (cond (inside-stringp leading-spaces)
                     ((null paren-stack)
                      (when (= left-i 0) (setq left-i leading-spaces))
                      left-i)
                     (t (let* ((lp (car paren-stack))
                               (nas (lparen-lisp-indent-num lp))
                               (nfs (lparen-num-finished-subforms lp))
                               (extra-w 0))
                          (when (< nfs nas) ;(and (>= nas 0) (< nfs nas))
                            (incf (lparen-num-finished-subforms lp))
                            (setq extra-w 2))
                          (+ (lparen-spaces-before lp)
                             extra-w))))))
        (setq curr-line (string-trim-blanks curr-line))
        (unless (string= curr-line "")
          (dotimes (k curr-left-i) (write-char #\space))
          (princ curr-line))
        (terpri)
                                        ;
        (let ((i 0) (n (length curr-line)) (escapep nil)
              (token-interstice-p nil))
          (flet ((incr-finished-subforms ()
                   (unless token-interstice-p
                     (when paren-stack
                       (incf (lparen-num-finished-subforms
                              (car paren-stack))))
                     (setq token-interstice-p t))))
                                        ;
            (loop
              (when (>= i n) (return))
              (let ((c (char curr-line i)))
                (cond (escapep (setq escapep nil))
                      ((char= c #\\) (setq token-interstice-p nil escapep t))
                      (inside-stringp (when (char= c #\")
                                        (setq inside-stringp nil)
                                        (incr-finished-subforms)))
                      ((char= c #\;) (incr-finished-subforms) (return))
                      ((char= c #\") (incr-finished-subforms) (setq inside-stringp t))
                      ((member c '(#\space #\tab) :test #'char=)
                       (incr-finished-subforms))
                      ((member c '(#\( #\[) :test #'char=)
                       (incr-finished-subforms)
                       (multiple-value-bind (delta-indent lisp-indent-num j)
                           (calc-subindent curr-line (1+ i) n)
                         (push (make-lparen :spaces-before (+ 1 i curr-left-i delta-indent)
                                            :lisp-indent-num lisp-indent-num
                                            :num-finished-subforms -1)
                               paren-stack)
                         (setq token-interstice-p t)
                         (let ((inext (1+ i)))
                           (when (> j inext)
                             (setq inext j token-interstice-p nil))
                           (setq i (1- inext)))))
                      ((member c '(#\) #\]) :test #'char=)
                       (setq token-interstice-p nil)
                       (cond (paren-stack (pop paren-stack))
                             (t (setq left-i 0))))
                      (t (setq token-interstice-p nil))))
              (incf i))
            (incr-finished-subforms)))))))

(defmacro with-indenting-output (&body body)
  "Indent *STANDARD-OUTPUT* while evaluating BODY."
  (let ((str (gensym)))
    `(let ((,str (make-array
		  '(0)
		  :element-type 'character
		  :fill-pointer 0
		  :adjustable t)))
       (with-output-to-string (*standard-output* ,str)
	 ,@body)
       (format *debug-io* "~S" ,str)
       (with-input-from-string (*standard-input* ,str)
	 (indent-lines)))))
